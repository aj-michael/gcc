package edu.rosehulman.minijavac.generated;

import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;

import edu.rosehulman.minijavac.ast.*;
import edu.rosehulman.minijavac.ast.BinaryOperation.BinaryOperator;

import java_cup.runtime.*;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;

parser code {:
  Lexer lexer;
  LinkedList<String> output = new LinkedList<>();
  static final String RECOVERY = "Error recovery to next semicolon.";

  public Parser(Lexer lexer) {
    this.lexer = lexer;
  }

  public String getParseLog() {
    return Joiner.on("\n").join(output) + "\n";
  }

  public void syntax_error(Symbol current) {
    output.add("\n\nERROR in line " + current.left + " and column " + current.right + ": Syntax error\n");
    output.add(RECOVERY);
  }

  @Override
  public void unrecovered_syntax_error(Symbol current) {
    if (output.peekLast().equals(RECOVERY)) {
        output.pollLast();
    }
    output.add("\n\nERROR in line " + current.left + " and column " + current.right + ": Couldn't repair and continue parse\n\nException processing file: Can't recover from previous error(s)");
  }

  public Program parseProgram() throws Exception {
    Symbol symbol = super.parse();
    return symbol != null && symbol.value instanceof Program ? (Program) symbol.value : null;
  }
:};

scan with {:
    Symbol symbol = lexer.next_token();
    if (symbol.sym == Symbols.UnmatchedCharacter) {
        output.add(String.format("Unmatched character '%s' at line %d and column %d", symbol.value, symbol.left, symbol.right));
        return scan();
    } else {
        return symbol;
    }
:};

terminal And;
terminal Assignment;
terminal Boolean;
terminal Class;
terminal Comma;
terminal Divide;
terminal Dot;
terminal Else;
terminal Equals;
terminal Extends;
terminal False;
terminal GreaterThan;
terminal GreaterThanOrEqual;
terminal If;
terminal Int;
terminal Integer Integer;
terminal LeftBrace;
terminal LeftBracket;
terminal LeftParenthesis;
terminal LessThan;
terminal LessThanOrEqual;
terminal Main;
terminal Minus;
terminal Multiply;
terminal New;
terminal Not;
terminal NotEquals;
terminal Null;
terminal Or;
terminal Plus;
terminal Public;
terminal Return;
terminal RightBrace;
terminal RightBracket;
terminal RightParenthesis;
terminal Semicolon;
terminal Static;
terminal Lexer.DisplayableValue<String> ID;
terminal String;
terminal SystemOutPrintln;
terminal This;
terminal True;
terminal Void;
terminal While;

terminal String UnmatchedCharacter;

non terminal CallExpr;
non terminal ClassDeclaration ClassDecl;
non terminal List<ClassDeclaration> ClassDeclList;
non terminal Map.Entry<String, String> ClassVarDecl;
non terminal Map<String, String> ClassVarDeclList;
non terminal LinkedHashMap<String, String> FormalList;
non terminal Expression Expr;
non terminal List<Expression> ExprList;
non terminal Map.Entry<String, String> Formal;
non terminal LiteralExpr;
non terminal ClassDeclaration MainClassDecl;
non terminal MethodDeclaration MethodDecl;
non terminal List<MethodDeclaration> MethodDeclList;
non terminal List<Expression> OptExprList;
non terminal Optional<String> OptExtends;
non terminal LinkedHashMap<String, String> OptFormalList;
non terminal ParenExpr;
non terminal Program Program;
non terminal Statement Stmt;
non terminal List<Statement> StmtList;
non terminal String Type;
non terminal Expression UnaryExpr;

precedence left Or;
precedence left And;
precedence left Equals, NotEquals;
precedence left GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual;
precedence left Plus, Minus;
precedence left Multiply, Divide;
precedence left Not;

start with Program;

Program ::= MainClassDecl:mcl ClassDeclList:cdl
    {:
        output.add("Program ::= MainClassDecl ClassDeclList");
        RESULT = new Program(mcl, cdl);
    :}
    ;
ClassDeclList ::= ClassDeclList:cdl ClassDecl:cd
    {:
        output.add("ClassDeclList ::= ClassDeclList ClassDecl");
        cdl.add(cd);
        RESULT = cdl;
    :}
    |
    {:
        output.add("ClassDeclList ::= ");
        RESULT = new LinkedList<>();
    :}
    ;
MainClassDecl ::= Class ID:name LeftBrace Public Static Void Main LeftParenthesis String LeftBracket RightBracket ID RightParenthesis LeftBrace StmtList:sl RightBrace RightBrace
    {:
        output.add("MainClassDecl ::= ...");
        MethodDeclaration main = new MainMethodDeclaration(sl);
        RESULT = new ClassDeclaration(name.value, Optional.empty(), ImmutableMap.of(), ImmutableList.of(main));
    :}
    ;
StmtList ::= StmtList:sl Stmt:s
    {:
        output.add("StmtList ::= StmtList Stmt");
        sl.add(s);
        RESULT = sl;
    :}
    |
    {:
        output.add("StmtList ::= ");
        RESULT = new LinkedList<>();
    :}
    ;
ClassDecl ::= Class ID:name OptExtends:parent LeftBrace ClassVarDeclList:cvdl MethodDeclList:mdl RightBrace
    {:
        output.add("ClassDecl ::= ...");
        RESULT = new ClassDeclaration(name.value, parent, cvdl, mdl);
    :}
    ;
OptExtends ::= Extends ID:name
    {:
        output.add("OptExtends ::= EXTENDS ID");
        RESULT = Optional.of(name.value);
    :}
    |
    {:
        output.add("OptExtends ::= ");
        RESULT = Optional.empty();
    :}
    ;
ClassVarDeclList ::= ClassVarDeclList:cvdl ClassVarDecl:cvd
    {:
        output.add("ClassVarDeclList ::= ClassVarDeclList ClassVarDecl");
        cvdl.put(cvd.getKey(), cvd.getValue());
        RESULT = cvdl;
    :}
    |
    {:
        output.add("ClassVarDeclList ::= ");
        RESULT = new HashMap<>();
    :}
    ;
ClassVarDecl ::= Type:type ID:name Semicolon
    {:
        output.add("ClassVarDecl ::= Type ID SEMI");
        RESULT = Maps.immutableEntry(name.value, type);
    :}
    ;
MethodDeclList ::= MethodDeclList:mdl MethodDecl:md
    {:
        output.add("MethodDeclList ::= MethodDeclList MethodDecl");
        mdl.add(md);
        RESULT = mdl;
    :}
    |
    {:
        output.add("MethodDeclList ::= ");
        RESULT = new LinkedList<>();
    :}
    ;
MethodDecl ::= Public Type:returnType ID:name LeftParenthesis OptFormalList:ofl RightParenthesis LeftBrace StmtList:sl Return Expr:e Semicolon RightBrace
    {:
        output.add("MethodDecl ::= ... ");
        RESULT = new MethodDeclaration(name.value, ofl, sl, returnType, e);
    :}
    ;
OptFormalList ::= FormalList:fl
    {:
        output.add("OptFormalList ::= FormalList");
        RESULT = fl;
    :}
    |
    {:
        output.add("OptFormalList ::= ");
        RESULT = new LinkedHashMap<>();
    :}
    ;
FormalList ::= FormalList:fl Comma Formal:f
    {:
        output.add("FormalList ::= FormalList COMMA Formal");
        fl.put(f.getKey(), f.getValue());
        RESULT = fl;
    :}
    | Formal:f
    {:
        output.add("FormalList ::= Formal");
        LinkedHashMap<String, String> fl = new LinkedHashMap<>();
        fl.put(f.getKey(), f.getValue());
        RESULT = fl;
    :}
    ;
Formal ::= Type:type ID:name
    {:
        output.add("Formal ::= Type ID");
        RESULT = Maps.immutableEntry(name.value, type);
    :}
    ;
Type ::= Int
    {:
        output.add("Type ::= INT");
        RESULT = "int";
    :}
    | Boolean
    {:
        output.add("Type ::= BOOLEAN");
        RESULT = "boolean";
    :}
    | ID:name
    {:
        output.add("Type ::= ID");
        RESULT = name.value;
    :}
    ;
Stmt ::= Type:type ID:id Assignment Expr:expression Semicolon
    {:
        output.add("Stmt ::= Type ID GETS Expr SEMI");
        RESULT = new AssignmentStatement(type, id.value, expression);
    :}
    | LeftBrace StmtList:sl RightBrace
    {:
        output.add("Stmt ::= LBRACE StmtList RBRACE");
        RESULT = new BlockStatement(sl);
    :}
    | If LeftParenthesis Expr:condition RightParenthesis Stmt:trueStatement Else Stmt:falseStatement
    {:
        output.add("Stmt ::= IF LPAREN Expr RPAREN Stmt ELSE Stmt");
        RESULT = new IfStatement(condition, trueStatement, falseStatement);
    :}
    | While LeftParenthesis Expr:condition RightParenthesis Stmt:statement
    {:
        output.add("Stmt ::= WHILE LPAREN Expr RPAREN Stmt");
        RESULT = new WhileStatement(condition, statement);
    :}
    | SystemOutPrintln LeftParenthesis Expr:expression RightParenthesis Semicolon
    {:
        output.add("Stmt ::= SYSTEMOUTPRINTLN LPAREN Expr RPAREN SEMI");
        RESULT = new PrintlnStatement(expression);
    :}
    | ID:id Assignment Expr:expression Semicolon
    {:
        output.add("Stmt ::= ID GETS Expr SEMI");
        RESULT = new AssignmentStatement(id.value, expression);
    :}
    | error Semicolon
    ;
Expr ::= Expr:e1 Plus Expr:e2
    {:
        output.add("Expr ::= Expr PLUS Expr");
        RESULT = new BinaryOperation(BinaryOperator.PLUS, e1, e2);
    :}
    | Expr:e1 Minus Expr:e2
    {:
        output.add("Expr ::= Expr MINUS Expr");
        RESULT = new BinaryOperation(BinaryOperator.MINUS, e1, e2);
    :}
    | Expr:e1 Multiply Expr:e2
    {:
        output.add("Expr ::= Expr TIMES Expr");
        RESULT = new BinaryOperation(BinaryOperator.MULTIPLY, e1, e2);
    :}
    | Expr:e1 Divide Expr:e2
    {:
        output.add("Expr ::= Expr DIVIDE Expr");
        RESULT = new BinaryOperation(BinaryOperator.DIVIDE, e1, e2);
    :}
    | Expr:e1 LessThan Expr:e2
    {:
        output.add("Expr ::= Expr LT Expr");
        RESULT = new BinaryOperation(BinaryOperator.LT, e1, e2);
    :}
    | Expr:e1 LessThanOrEqual Expr:e2
    {:
        output.add("Expr ::= Expr LTE Expr");
        RESULT = new BinaryOperation(BinaryOperator.LTE, e1, e2);
    :}
    | Expr:e1 GreaterThanOrEqual Expr:e2
    {:
        output.add("Expr ::= Expr GTE Expr");
        RESULT = new BinaryOperation(BinaryOperator.GTE, e1, e2);
    :}
    | Expr:e1 GreaterThan Expr:e2
    {:
        output.add("Expr ::= Expr GT Expr");
        RESULT = new BinaryOperation(BinaryOperator.GT, e1, e2);
    :}
    | Expr:e1 Equals Expr:e2
    {:
        output.add("Expr ::= Expr EQ Expr");
        RESULT = new BinaryOperation(BinaryOperator.EQ, e1, e2);
    :}
    | Expr:e1 NotEquals Expr:e2
    {:
        output.add("Expr ::= Expr NE Expr");
        RESULT = new BinaryOperation(BinaryOperator.NEQ, e1, e2);
    :}
    | Expr:e1 And Expr:e2
    {:
        output.add("Expr ::= Expr AND Expr");
        RESULT = new BinaryOperation(BinaryOperator.AND, e1, e2);
    :}
    | Expr:e1 Or Expr:e2
    {:
        output.add("Expr ::= Expr OR Expr");
        RESULT = new BinaryOperation(BinaryOperator.OR, e1, e2);
    :}
    | UnaryExpr
    {:
        output.add("Expr ::= UnaryExpr");
    :}
    ;
OptExprList ::= ExprList:el
    {:
        output.add("OptExprList ::= ExprList");
        RESULT = el;
    :}
    |
    {:
        output.add("OptExprList ::=");
        RESULT = new LinkedList<>();
    :}
    ;
ExprList ::= ExprList:el Comma Expr:e
    {:
        output.add("ExprList ::= ExprList COMMA Expr");
        el.add(e);
        RESULT = el;
    :}
    | Expr:e
    {:
        output.add("ExprList ::= Expr");
        List<Expression> el = new LinkedList<>();
        el.add(e);
        RESULT = el;
    :}
    ;
LiteralExpr ::= ID
    {:
        output.add("LiteralExpr ::= ID");
    :}
    | Integer
    {:
        output.add("LiteralExpr ::= INTEGER");
    :}
    | True
    {:
        output.add("LiteralExpr ::= TRUE");
    :}
    | ParenExpr
    {:
        output.add("LiteralExpr ::= ParenExpr");
    :}
    | False
    {:
        output.add("LiteralExpr ::= FALSE");
    :}
    | This
    {:
        output.add("LiteralExpr ::= THIS");
    :}
    | Null
    {:
        output.add("LiteralExpr ::= NULL");
    :}
    ;
ParenExpr ::= LeftParenthesis Expr RightParenthesis
    {:
        output.add("ParenExpr ::= LPAREN Expr RPAREN");
    :}
    ;
UnaryExpr ::= CallExpr
    {:
        output.add("UnaryExpr ::= CallExpr");
    :}
    | Minus UnaryExpr
    {:
        output.add("UnaryExpr ::= MINUS UnaryExpr");
    :}
    | Not UnaryExpr
    {:
        output.add("UnaryExpr ::= NOT UnaryExpr");
    :}
    ;
CallExpr ::= LiteralExpr
    {:
        output.add("CallExpr ::= LiteralExpr");
    :}
    | New ID LeftParenthesis RightParenthesis
    {:
        output.add("CallExpr ::= NEW ID LPAREN RPAREN");
    :}
    | CallExpr Dot ID LeftParenthesis OptExprList RightParenthesis
    {:
        output.add("CallExpr ::= CallExpr DOT ID LPAREN OptExprList RPAREN");
    :}
    ;
