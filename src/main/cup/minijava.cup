package edu.rosehulman.minijavac.generated;

import com.google.common.base.Joiner;

import edu.rosehulman.minijavac.ast.*;

import java_cup.runtime.*;

import java.util.ArrayList;
import java.util.List;

parser code {:
  Lexer lexer;
  List<String> output = new ArrayList<>();

  public Parser(Lexer lexer) {
    this.lexer = lexer;
  }

  public String getParseLog() {
    return Joiner.on("\n").join(output) + "\n";
  }

:};

scan with {:
  return lexer.next_token();
:};

terminal And;
terminal Assignment;
terminal Boolean;
terminal Class;
terminal Comma;
terminal Divide;
terminal Dot;
terminal Else;
terminal Equals;
terminal Extends;
terminal False;
terminal GreaterThan;
terminal GreaterThanOrEqual;
terminal If;
terminal Int;
terminal Integer Integer;
terminal LeftBrace;
terminal LeftBracket;
terminal LeftParenthesis;
terminal LessThan;
terminal LessThanOrEqual;
terminal Main;
terminal Minus;
terminal Multiply;
terminal New;
terminal Not;
terminal NotEquals;
terminal Null;
terminal Or;
terminal Plus;
terminal Public;
terminal Return;
terminal RightBrace;
terminal RightBracket;
terminal RightParenthesis;
terminal Semicolon;
terminal Static;
terminal String ID;
terminal String;
terminal SystemOutPrintln;
terminal This;
terminal True;
terminal Void;
terminal While;

non terminal CallExpr;
non terminal ClassDeclNode ClassDecl;
non terminal List<ClassDeclNode> ClassDeclList;
non terminal ClassVarDeclNode ClassVarDecl;
non terminal List<ClassVarDeclNode> ClassVarDeclList;
non terminal List<FormalNode> FormalList;
non terminal ExprNode Expr;
non terminal List<ExprNode> ExprList;
non terminal FormalNode Formal;
non terminal LiteralExpr;
non terminal MainClassDeclNode MainClassDecl;
non terminal MethodDeclNode MethodDecl;
non terminal List<MethodDeclNode> MethodDeclList;
non terminal OptExprListNode OptExprList;
non terminal OptExtendsNode OptExtends;
non terminal OptFormalListNode OptFormalList;
non terminal ParenExpr;
non terminal ProgramNode Program;
non terminal StmtNode Stmt;
non terminal List<StmtNode> StmtList;
non terminal TypeNode Type;
non terminal UnaryExpr;

precedence left Or;
precedence left And;
precedence left Equals, NotEquals;
precedence left GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual;
precedence left Plus, Minus;
precedence left Multiply, Divide;
precedence left Not;

start with Program;

Program ::= MainClassDecl:mcl ClassDeclList:cdl
    {:
        output.add("Program ::= MainClassDecl ClassDeclList");
        RESULT = new ProgramNode(mcl, cdl);
    :}
    ;
ClassDeclList ::= ClassDeclList:cdl ClassDecl:cd
    {:
        output.add("ClassDeclList ::= ClassDeclList ClassDecl");
        cdl.add(cd); RESULT = cdl;
    :}
    |
    {:
        output.add("ClassDeclList ::= ");
        RESULT = new ArrayList<>();
    :}
    ;
MainClassDecl ::= Class ID LeftBrace Public Static Void Main LeftParenthesis String LeftBracket RightBracket ID RightParenthesis LeftBrace StmtList:sl RightBrace RightBrace
    {:
        output.add("MainClassDecl ::= ...");
        RESULT = new MainClassDeclNode(sl);
    :}
    ;
StmtList ::= StmtList:sl Stmt:s
    {:
        output.add("StmtList ::= StmtList Stmt");
        sl.add(s); RESULT = sl;
    :}
    |
    {:
        output.add("StmtList ::= ");
        RESULT = new ArrayList<>();
    :}
    ;
ClassDecl ::= Class ID OptExtends LeftBrace ClassVarDeclList:cvdl MethodDeclList:mdl RightBrace
    {:
        output.add("ClassDecl ::= ...");
        RESULT = new ClassDeclNode(cvdl, mdl);
    :}
    ;
OptExtends ::= Extends ID
    {:
        output.add("OptExtends ::= EXTENDS ID");
    :}
    |
    {:
        output.add("OptExtends ::= ");
    :}
    ;
ClassVarDeclList ::= ClassVarDeclList ClassVarDecl
    {:
        output.add("ClassVarDeclList ::= ClassVarDeclList ClassVarDecl");
    :}
    |
    {:
        output.add("ClassVarDeclList ::= ");
    :}
    ;
ClassVarDecl ::= Type ID Semicolon
    {:
        output.add("ClassVarDecl ::= Type ID SEMI");
    :}
    ;
MethodDeclList ::= MethodDeclList MethodDecl
    {:
        output.add("MethodDeclList ::= MethodDeclList MethodDecl");
    :}
    |
    {:
        output.add("MethodDeclList ::= ");
    :}
    ;
MethodDecl ::= Public Type ID LeftParenthesis OptFormalList RightParenthesis LeftBrace StmtList Return Expr Semicolon RightBrace
    {:
        output.add("MethodDecl ::= ... ");
    :}
    ;
OptFormalList ::= FormalList
    {:
        output.add("OptFormalList ::= FormalList");
    :}
    |
    {:
        output.add("OptFormalList ::= ");
    :}
    ;
FormalList ::= FormalList Comma Formal
    {:
        output.add("FormalList ::= FormalList COMMA Formal");
    :}
    | Formal
    {:
        output.add("FormalList ::= Formal");
    :}
    ;
Formal ::= Type ID
    {:
        output.add("Formal ::= Type ID");
    :}
    ;
Type ::= Int
    {:
        output.add("Type ::= INT");
    :}
    | Boolean
    {:
        output.add("Type ::= BOOLEAN");
    :}
    | ID
    {:
        output.add("Type ::= ID");
    :}
    ;
Stmt ::= Type ID Assignment Expr Semicolon
    {:
        output.add("Stmt ::= Type ID GETS Expr SEMI");
        RESULT = new StmtNode();
    :}
    | LeftBrace StmtList RightBrace
    {:
        output.add("Stmt ::= LBRACE StmtList RBRACE");
        RESULT = new StmtNode();
    :}
    | If LeftParenthesis Expr RightParenthesis Stmt Else Stmt
    {:
        output.add("Stmt ::= IF LPAREN Expr RPAREN Stmt ELSE Stmt");
        RESULT = new StmtNode();
    :}
    | While LeftParenthesis Expr RightParenthesis Stmt
    {:
        output.add("Stmt ::= WHILE LPAREN Expr RPAREN Stmt");
        RESULT = new StmtNode();
    :}
    | SystemOutPrintln LeftParenthesis Expr RightParenthesis Semicolon
    {:
        output.add("Stmt ::= SYSTEMOUTPRINTLN LPAREN Expr RPAREN SEMI");
        RESULT = new StmtNode();
    :}
    | ID Assignment Expr Semicolon
    {:
        output.add("Stmt ::= ID GETS Expr SEMI");
        RESULT = new StmtNode();
    :}
    ;
Expr ::= Expr Plus Expr
    {:
        output.add("Expr ::= Expr PLUS Expr");
        RESULT = new ExprNode();
    :}
    | Expr Minus Expr
    {:
        output.add("Expr ::= Expr MINUS Expr");
        RESULT = new ExprNode();
    :}
    | Expr Multiply Expr
    {:
        output.add("Expr ::= Expr TIMES Expr");
        RESULT = new ExprNode();
    :}
    | Expr Divide Expr
    {:
        output.add("Expr ::= Expr DIVIDE Expr");
        RESULT = new ExprNode();
    :}
    | Expr LessThan Expr
    {:
        output.add("Expr ::= Expr LT Expr");
        RESULT = new ExprNode();
    :}
    | Expr LessThanOrEqual Expr
    {:
        output.add("Expr ::= Expr LTE Expr");
        RESULT = new ExprNode();
    :}
    | Expr GreaterThanOrEqual Expr
    {:
        output.add("Expr ::= Expr GTE Expr");
        RESULT = new ExprNode();
    :}
    | Expr GreaterThan Expr
    {:
        output.add("Expr ::= Expr GT Expr");
        RESULT = new ExprNode();
    :}
    | Expr Equals Expr
    {:
        output.add("Expr ::= Expr EQ Expr");
        RESULT = new ExprNode();
    :}
    | Expr NotEquals Expr
    {:
        output.add("Expr ::= Expr NE Expr");
        RESULT = new ExprNode();
    :}
    | Expr And Expr
    {:
        output.add("Expr ::= Expr AND Expr");
        RESULT = new ExprNode();
    :}
    | Expr Or Expr
    {:
        output.add("Expr ::= Expr OR Expr");
        RESULT = new ExprNode();
    :}
    | UnaryExpr
    {:
        output.add("Expr ::= UnaryExpr");
    :}
    ;
OptExprList ::= ExprList
    {:
        output.add("OptExprList ::= ExprList");
    :}
    |
    {:
        output.add("OptExprList ::=");
    :}
    ;
ExprList ::= ExprList Comma Expr
    {:
        output.add("ExprList ::= ExprList COMMA Expr");
    :}
    | Expr
    {:
        output.add("ExprList ::= Expr");
    :}
    ;
LiteralExpr ::= ID
    {:
        output.add("LiteralExpr ::= ID");
    :}
    | Integer
    {:
        output.add("LiteralExpr ::= INTEGER");
    :}
    | True
    {:
        output.add("LiteralExpr ::= TRUE");
    :}
    | ParenExpr
    {:
        output.add("LiteralExpr ::= ParenExpr");
    :}
    | False
    {:
        output.add("LiteralExpr ::= FALSE");
    :}
    | This
    {:
        output.add("LiteralExpr ::= THIS");
    :}
    | Null
    {:
        output.add("LiteralExpr ::= NULL");
    :}
    ;
ParenExpr ::= LeftParenthesis Expr RightParenthesis
    {:
        output.add("ParenExpr ::= LPAREN Expr RPAREN");
    :}
    ;
UnaryExpr ::= CallExpr
    {:
        output.add("UnaryExpr ::= CallExpr");
    :}
    | Minus UnaryExpr
    {:
        output.add("UnaryExpr ::= MINUS UnaryExpr");
    :}
    | Not UnaryExpr
    {:
        output.add("UnaryExpr ::= NOT UnaryExpr");
    :}
    ;
CallExpr ::= LiteralExpr
    {:
        output.add("CallExpr ::= LiteralExpr");
    :}
    | New ID LeftParenthesis RightParenthesis
    {:
        output.add("CallExpr ::= NEW ID LPAREN RPAREN");
    :}
    | CallExpr Dot ID LeftParenthesis OptExprList RightParenthesis
    {:
        output.add("CallExpr ::= CallExpr DOT ID LPAREN OptExprList RPAREN");
    :}
    ;
