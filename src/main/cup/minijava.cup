package edu.rosehulman.minijavac.generated;

import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Maps;

import edu.rosehulman.minijavac.ast.*;

import java_cup.runtime.*;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Optional;

parser code {:
  Lexer lexer;
  LinkedList<String> output = new LinkedList<>();
  static final String RECOVERY = "Error recovery to next semicolon.";

  public Parser(Lexer lexer) {
    this.lexer = lexer;
  }

  public String getParseLog() {
    return Joiner.on("\n").join(output) + "\n";
  }

  public void syntax_error(Symbol current) {
    output.add("\n\nERROR in line " + current.left + " and column " + current.right + ": Syntax error\n");
    output.add(RECOVERY);
  }

  @Override
  public void unrecovered_syntax_error(Symbol current) {
    if (output.peekLast().equals(RECOVERY)) {
        output.pollLast();
    }
    output.add("\n\nERROR in line " + current.left + " and column " + current.right + ": Couldn't repair and continue parse\n\nException processing file: Can't recover from previous error(s)");
  }
:};

scan with {:
    Symbol symbol = lexer.next_token();
    if (symbol.sym == Symbols.UnmatchedCharacter) {
        output.add(String.format("Unmatched character '%s' at line %d and column %d", symbol.value, symbol.left, symbol.right));
        return scan();
    } else {
        return symbol;
    }
:};

terminal And;
terminal Assignment;
terminal Boolean;
terminal Class;
terminal Comma;
terminal Divide;
terminal Dot;
terminal Else;
terminal Equals;
terminal Extends;
terminal False;
terminal GreaterThan;
terminal GreaterThanOrEqual;
terminal If;
terminal Int;
terminal Integer Integer;
terminal LeftBrace;
terminal LeftBracket;
terminal LeftParenthesis;
terminal LessThan;
terminal LessThanOrEqual;
terminal Main;
terminal Minus;
terminal Multiply;
terminal New;
terminal Not;
terminal NotEquals;
terminal Null;
terminal Or;
terminal Plus;
terminal Public;
terminal Return;
terminal RightBrace;
terminal RightBracket;
terminal RightParenthesis;
terminal Semicolon;
terminal Static;
terminal Lexer.DisplayableValue<String> ID;
terminal String;
terminal SystemOutPrintln;
terminal This;
terminal True;
terminal Void;
terminal While;

terminal String UnmatchedCharacter;

non terminal CallExpr;
non terminal ClassDeclaration ClassDecl;
non terminal List<ClassDeclaration> ClassDeclList;
non terminal Map.Entry<String, String> ClassVarDecl;
non terminal Map<String, String> ClassVarDeclList;
non terminal LinkedHashMap<String, String> FormalList;
non terminal Expr;
non terminal ExprList;
non terminal Map.Entry<String, String> Formal;
non terminal LiteralExpr;
non terminal ClassDeclaration MainClassDecl;
non terminal MethodDeclaration MethodDecl;
non terminal List<MethodDeclaration> MethodDeclList;
non terminal OptExprList;
non terminal Optional<String> OptExtends;
non terminal LinkedHashMap<String, String> OptFormalList;
non terminal ParenExpr;
non terminal Program Program;
non terminal Stmt;
non terminal StmtList;
non terminal String Type;
non terminal UnaryExpr;

precedence left Or;
precedence left And;
precedence left Equals, NotEquals;
precedence left GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual;
precedence left Plus, Minus;
precedence left Multiply, Divide;
precedence left Not;

start with Program;

Program ::= MainClassDecl:mcl ClassDeclList:cdl
    {:
        output.add("Program ::= MainClassDecl ClassDeclList");
        RESULT = new Program(mcl, cdl);
    :}
    ;
ClassDeclList ::= ClassDeclList:cdl ClassDecl:cd
    {:
        output.add("ClassDeclList ::= ClassDeclList ClassDecl");
        cdl.add(cd);
        RESULT = cdl;
    :}
    |
    {:
        output.add("ClassDeclList ::= ");
        RESULT = new LinkedList<>();
    :}
    ;
MainClassDecl ::= Class ID:name LeftBrace Public Static Void Main LeftParenthesis String LeftBracket RightBracket ID RightParenthesis LeftBrace StmtList:sl RightBrace RightBrace
    {:
        output.add("MainClassDecl ::= ...");
        RESULT = new ClassDeclaration(name.value, Optional.empty(), ImmutableMap.of(), ImmutableList.of());
    :}
    ;
StmtList ::= StmtList:sl Stmt:s
    {:
        output.add("StmtList ::= StmtList Stmt");
    :}
    |
    {:
        output.add("StmtList ::= ");
    :}
    ;
ClassDecl ::= Class ID:name OptExtends:parent LeftBrace ClassVarDeclList:cvdl MethodDeclList:mdl RightBrace
    {:
        output.add("ClassDecl ::= ...");
        RESULT = new ClassDeclaration(name.value, parent, cvdl, mdl);
    :}
    ;
OptExtends ::= Extends ID:name
    {:
        output.add("OptExtends ::= EXTENDS ID");
        RESULT = Optional.of(name.value);
    :}
    |
    {:
        output.add("OptExtends ::= ");
        RESULT = Optional.empty();
    :}
    ;
ClassVarDeclList ::= ClassVarDeclList:cvdl ClassVarDecl:cvd
    {:
        output.add("ClassVarDeclList ::= ClassVarDeclList ClassVarDecl");
        cvdl.put(cvd.getKey(), cvd.getValue());
        RESULT = cvdl;
    :}
    |
    {:
        output.add("ClassVarDeclList ::= ");
        RESULT = new HashMap<>();
    :}
    ;
ClassVarDecl ::= Type:type ID:name Semicolon
    {:
        output.add("ClassVarDecl ::= Type ID SEMI");
        RESULT = Maps.immutableEntry(name.value, type);
    :}
    ;
MethodDeclList ::= MethodDeclList:mdl MethodDecl:md
    {:
        output.add("MethodDeclList ::= MethodDeclList MethodDecl");
        mdl.add(md);
        RESULT = mdl;
    :}
    |
    {:
        output.add("MethodDeclList ::= ");
        RESULT = new LinkedList<>();
    :}
    ;
MethodDecl ::= Public Type:returnType ID:name LeftParenthesis OptFormalList:ofl RightParenthesis LeftBrace StmtList Return Expr Semicolon RightBrace
    {:
        output.add("MethodDecl ::= ... ");
        RESULT = new MethodDeclaration(name.value, returnType, ofl);
    :}
    ;
OptFormalList ::= FormalList:fl
    {:
        output.add("OptFormalList ::= FormalList");
        RESULT = fl;
    :}
    |
    {:
        output.add("OptFormalList ::= ");
        RESULT = new LinkedHashMap<>();
    :}
    ;
FormalList ::= FormalList:fl Comma Formal:f
    {:
        output.add("FormalList ::= FormalList COMMA Formal");
        fl.put(f.getKey(), f.getValue());
        RESULT = fl;
    :}
    | Formal:f
    {:
        output.add("FormalList ::= Formal");
        LinkedHashMap<String, String> fl = new LinkedHashMap<>();
        fl.put(f.getKey(), f.getValue());
        RESULT = fl;
    :}
    ;
Formal ::= Type:type ID:name
    {:
        output.add("Formal ::= Type ID");
        RESULT = Maps.immutableEntry(name.value, type);
    :}
    ;
Type ::= Int
    {:
        output.add("Type ::= INT");
        RESULT = "int";
    :}
    | Boolean
    {:
        output.add("Type ::= BOOLEAN");
        RESULT = "boolean";
    :}
    | ID:name
    {:
        output.add("Type ::= ID");
        RESULT = name.value;
    :}
    ;
Stmt ::= Type ID Assignment Expr Semicolon
    {:
        output.add("Stmt ::= Type ID GETS Expr SEMI");
    :}
    | LeftBrace StmtList RightBrace
    {:
        output.add("Stmt ::= LBRACE StmtList RBRACE");
    :}
    | If LeftParenthesis Expr RightParenthesis Stmt Else Stmt
    {:
        output.add("Stmt ::= IF LPAREN Expr RPAREN Stmt ELSE Stmt");
    :}
    | While LeftParenthesis Expr RightParenthesis Stmt
    {:
        output.add("Stmt ::= WHILE LPAREN Expr RPAREN Stmt");
    :}
    | SystemOutPrintln LeftParenthesis Expr RightParenthesis Semicolon
    {:
        output.add("Stmt ::= SYSTEMOUTPRINTLN LPAREN Expr RPAREN SEMI");
    :}
    | ID Assignment Expr Semicolon
    {:
        output.add("Stmt ::= ID GETS Expr SEMI");
    :}
    | error Semicolon
    ;
Expr ::= Expr Plus Expr
    {:
        output.add("Expr ::= Expr PLUS Expr");
    :}
    | Expr Minus Expr
    {:
        output.add("Expr ::= Expr MINUS Expr");
    :}
    | Expr Multiply Expr
    {:
        output.add("Expr ::= Expr TIMES Expr");
    :}
    | Expr Divide Expr
    {:
        output.add("Expr ::= Expr DIVIDE Expr");
    :}
    | Expr LessThan Expr
    {:
        output.add("Expr ::= Expr LT Expr");
    :}
    | Expr LessThanOrEqual Expr
    {:
        output.add("Expr ::= Expr LTE Expr");
    :}
    | Expr GreaterThanOrEqual Expr
    {:
        output.add("Expr ::= Expr GTE Expr");
    :}
    | Expr GreaterThan Expr
    {:
        output.add("Expr ::= Expr GT Expr");
    :}
    | Expr Equals Expr
    {:
        output.add("Expr ::= Expr EQ Expr");
    :}
    | Expr NotEquals Expr
    {:
        output.add("Expr ::= Expr NE Expr");
    :}
    | Expr And Expr
    {:
        output.add("Expr ::= Expr AND Expr");
    :}
    | Expr Or Expr
    {:
        output.add("Expr ::= Expr OR Expr");
    :}
    | UnaryExpr
    {:
        output.add("Expr ::= UnaryExpr");
    :}
    ;
OptExprList ::= ExprList
    {:
        output.add("OptExprList ::= ExprList");
    :}
    |
    {:
        output.add("OptExprList ::=");
    :}
    ;
ExprList ::= ExprList Comma Expr
    {:
        output.add("ExprList ::= ExprList COMMA Expr");
    :}
    | Expr
    {:
        output.add("ExprList ::= Expr");
    :}
    ;
LiteralExpr ::= ID
    {:
        output.add("LiteralExpr ::= ID");
    :}
    | Integer
    {:
        output.add("LiteralExpr ::= INTEGER");
    :}
    | True
    {:
        output.add("LiteralExpr ::= TRUE");
    :}
    | ParenExpr
    {:
        output.add("LiteralExpr ::= ParenExpr");
    :}
    | False
    {:
        output.add("LiteralExpr ::= FALSE");
    :}
    | This
    {:
        output.add("LiteralExpr ::= THIS");
    :}
    | Null
    {:
        output.add("LiteralExpr ::= NULL");
    :}
    ;
ParenExpr ::= LeftParenthesis Expr RightParenthesis
    {:
        output.add("ParenExpr ::= LPAREN Expr RPAREN");
    :}
    ;
UnaryExpr ::= CallExpr
    {:
        output.add("UnaryExpr ::= CallExpr");
    :}
    | Minus UnaryExpr
    {:
        output.add("UnaryExpr ::= MINUS UnaryExpr");
    :}
    | Not UnaryExpr
    {:
        output.add("UnaryExpr ::= NOT UnaryExpr");
    :}
    ;
CallExpr ::= LiteralExpr
    {:
        output.add("CallExpr ::= LiteralExpr");
    :}
    | New ID LeftParenthesis RightParenthesis
    {:
        output.add("CallExpr ::= NEW ID LPAREN RPAREN");
    :}
    | CallExpr Dot ID LeftParenthesis OptExprList RightParenthesis
    {:
        output.add("CallExpr ::= CallExpr DOT ID LPAREN OptExprList RPAREN");
    :}
    ;
