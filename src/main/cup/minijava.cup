package edu.rosehulman.minijavac.generated;

import com.google.common.base.Joiner;

import java_cup.runtime.*;

import java.util.LinkedList;
import java.util.List;

parser code {:
  Lexer lexer;
  LinkedList<String> output = new LinkedList<>();
  static final String RECOVERY = "Error recovery to next semicolon.";

  public Parser(Lexer lexer) {
    this.lexer = lexer;
  }

  public String getParseLog() {
    return Joiner.on("\n").join(output) + "\n";
  }

  public void syntax_error(Symbol current) {
    output.add("\n\nERROR in line " + current.left + " and column " + current.right + ": Syntax error\n");
    output.add(RECOVERY);
  }

  @Override
  public void unrecovered_syntax_error(Symbol current) {
    if (output.peekLast().equals(RECOVERY)) {
        output.pollLast();
    }
    output.add("\n\nERROR in line " + current.left + " and column " + current.right + ": Couldn't repair and continue parse\n\nException processing file: Can't recover from previous error(s)");
  }
:};

scan with {:
    Symbol symbol = lexer.next_token();
    if (symbol.sym == Symbols.UnmatchedCharacter) {
        output.add(String.format("Unmatched character '%s' at line %d and column %d", symbol.value, symbol.left, symbol.right));
        return scan();
    } else {
        return symbol;
    }
:};

terminal And;
terminal Assignment;
terminal Boolean;
terminal Class;
terminal Comma;
terminal Divide;
terminal Dot;
terminal Else;
terminal Equals;
terminal Extends;
terminal False;
terminal GreaterThan;
terminal GreaterThanOrEqual;
terminal If;
terminal Int;
terminal Integer Integer;
terminal LeftBrace;
terminal LeftBracket;
terminal LeftParenthesis;
terminal LessThan;
terminal LessThanOrEqual;
terminal Main;
terminal Minus;
terminal Multiply;
terminal New;
terminal Not;
terminal NotEquals;
terminal Null;
terminal Or;
terminal Plus;
terminal Public;
terminal Return;
terminal RightBrace;
terminal RightBracket;
terminal RightParenthesis;
terminal Semicolon;
terminal Static;
terminal String ID;
terminal String;
terminal SystemOutPrintln;
terminal This;
terminal True;
terminal Void;
terminal While;

terminal String UnmatchedCharacter;

non terminal CallExpr;
non terminal ClassDecl;
non terminal ClassDeclList;
non terminal ClassVarDecl;
non terminal ClassVarDeclList;
non terminal FormalList;
non terminal Expr;
non terminal ExprList;
non terminal Formal;
non terminal LiteralExpr;
non terminal MainClassDecl;
non terminal MethodDecl;
non terminal MethodDeclList;
non terminal OptExprList;
non terminal OptExtends;
non terminal OptFormalList;
non terminal ParenExpr;
non terminal Program;
non terminal Stmt;
non terminal StmtList;
non terminal Type;
non terminal UnaryExpr;

precedence left Or;
precedence left And;
precedence left Equals, NotEquals;
precedence left GreaterThan, GreaterThanOrEqual, LessThan, LessThanOrEqual;
precedence left Plus, Minus;
precedence left Multiply, Divide;
precedence left Not;

start with Program;

Program ::= MainClassDecl:mcl ClassDeclList:cdl
    {:
        output.add("Program ::= MainClassDecl ClassDeclList");
    :}
    ;
ClassDeclList ::= ClassDeclList:cdl ClassDecl:cd
    {:
        output.add("ClassDeclList ::= ClassDeclList ClassDecl");
    :}
    |
    {:
        output.add("ClassDeclList ::= ");
    :}
    ;
MainClassDecl ::= Class ID LeftBrace Public Static Void Main LeftParenthesis String LeftBracket RightBracket ID RightParenthesis LeftBrace StmtList:sl RightBrace RightBrace
    {:
        output.add("MainClassDecl ::= ...");
    :}
    ;
StmtList ::= StmtList:sl Stmt:s
    {:
        output.add("StmtList ::= StmtList Stmt");
    :}
    |
    {:
        output.add("StmtList ::= ");
    :}
    ;
ClassDecl ::= Class ID OptExtends LeftBrace ClassVarDeclList:cvdl MethodDeclList:mdl RightBrace
    {:
        output.add("ClassDecl ::= ...");
    :}
    ;
OptExtends ::= Extends ID
    {:
        output.add("OptExtends ::= EXTENDS ID");
    :}
    |
    {:
        output.add("OptExtends ::= ");
    :}
    ;
ClassVarDeclList ::= ClassVarDeclList ClassVarDecl
    {:
        output.add("ClassVarDeclList ::= ClassVarDeclList ClassVarDecl");
    :}
    |
    {:
        output.add("ClassVarDeclList ::= ");
    :}
    ;
ClassVarDecl ::= Type ID Semicolon
    {:
        output.add("ClassVarDecl ::= Type ID SEMI");
    :}
    ;
MethodDeclList ::= MethodDeclList MethodDecl
    {:
        output.add("MethodDeclList ::= MethodDeclList MethodDecl");
    :}
    |
    {:
        output.add("MethodDeclList ::= ");
    :}
    ;
MethodDecl ::= Public Type ID LeftParenthesis OptFormalList RightParenthesis LeftBrace StmtList Return Expr Semicolon RightBrace
    {:
        output.add("MethodDecl ::= ... ");
    :}
    ;
OptFormalList ::= FormalList
    {:
        output.add("OptFormalList ::= FormalList");
    :}
    |
    {:
        output.add("OptFormalList ::= ");
    :}
    ;
FormalList ::= FormalList Comma Formal
    {:
        output.add("FormalList ::= FormalList COMMA Formal");
    :}
    | Formal
    {:
        output.add("FormalList ::= Formal");
    :}
    ;
Formal ::= Type ID
    {:
        output.add("Formal ::= Type ID");
    :}
    ;
Type ::= Int
    {:
        output.add("Type ::= INT");
    :}
    | Boolean
    {:
        output.add("Type ::= BOOLEAN");
    :}
    | ID
    {:
        output.add("Type ::= ID");
    :}
    ;
Stmt ::= Type ID Assignment Expr Semicolon
    {:
        output.add("Stmt ::= Type ID GETS Expr SEMI");
    :}
    | LeftBrace StmtList RightBrace
    {:
        output.add("Stmt ::= LBRACE StmtList RBRACE");
    :}
    | If LeftParenthesis Expr RightParenthesis Stmt Else Stmt
    {:
        output.add("Stmt ::= IF LPAREN Expr RPAREN Stmt ELSE Stmt");
    :}
    | While LeftParenthesis Expr RightParenthesis Stmt
    {:
        output.add("Stmt ::= WHILE LPAREN Expr RPAREN Stmt");
    :}
    | SystemOutPrintln LeftParenthesis Expr RightParenthesis Semicolon
    {:
        output.add("Stmt ::= SYSTEMOUTPRINTLN LPAREN Expr RPAREN SEMI");
    :}
    | ID Assignment Expr Semicolon
    {:
        output.add("Stmt ::= ID GETS Expr SEMI");
    :}
    | error Semicolon
    ;
Expr ::= Expr Plus Expr
    {:
        output.add("Expr ::= Expr PLUS Expr");
    :}
    | Expr Minus Expr
    {:
        output.add("Expr ::= Expr MINUS Expr");
    :}
    | Expr Multiply Expr
    {:
        output.add("Expr ::= Expr TIMES Expr");
    :}
    | Expr Divide Expr
    {:
        output.add("Expr ::= Expr DIVIDE Expr");
    :}
    | Expr LessThan Expr
    {:
        output.add("Expr ::= Expr LT Expr");
    :}
    | Expr LessThanOrEqual Expr
    {:
        output.add("Expr ::= Expr LTE Expr");
    :}
    | Expr GreaterThanOrEqual Expr
    {:
        output.add("Expr ::= Expr GTE Expr");
    :}
    | Expr GreaterThan Expr
    {:
        output.add("Expr ::= Expr GT Expr");
    :}
    | Expr Equals Expr
    {:
        output.add("Expr ::= Expr EQ Expr");
    :}
    | Expr NotEquals Expr
    {:
        output.add("Expr ::= Expr NE Expr");
    :}
    | Expr And Expr
    {:
        output.add("Expr ::= Expr AND Expr");
    :}
    | Expr Or Expr
    {:
        output.add("Expr ::= Expr OR Expr");
    :}
    | UnaryExpr
    {:
        output.add("Expr ::= UnaryExpr");
    :}
    ;
OptExprList ::= ExprList
    {:
        output.add("OptExprList ::= ExprList");
    :}
    |
    {:
        output.add("OptExprList ::=");
    :}
    ;
ExprList ::= ExprList Comma Expr
    {:
        output.add("ExprList ::= ExprList COMMA Expr");
    :}
    | Expr
    {:
        output.add("ExprList ::= Expr");
    :}
    ;
LiteralExpr ::= ID
    {:
        output.add("LiteralExpr ::= ID");
    :}
    | Integer
    {:
        output.add("LiteralExpr ::= INTEGER");
    :}
    | True
    {:
        output.add("LiteralExpr ::= TRUE");
    :}
    | ParenExpr
    {:
        output.add("LiteralExpr ::= ParenExpr");
    :}
    | False
    {:
        output.add("LiteralExpr ::= FALSE");
    :}
    | This
    {:
        output.add("LiteralExpr ::= THIS");
    :}
    | Null
    {:
        output.add("LiteralExpr ::= NULL");
    :}
    ;
ParenExpr ::= LeftParenthesis Expr RightParenthesis
    {:
        output.add("ParenExpr ::= LPAREN Expr RPAREN");
    :}
    ;
UnaryExpr ::= CallExpr
    {:
        output.add("UnaryExpr ::= CallExpr");
    :}
    | Minus UnaryExpr
    {:
        output.add("UnaryExpr ::= MINUS UnaryExpr");
    :}
    | Not UnaryExpr
    {:
        output.add("UnaryExpr ::= NOT UnaryExpr");
    :}
    ;
CallExpr ::= LiteralExpr
    {:
        output.add("CallExpr ::= LiteralExpr");
    :}
    | New ID LeftParenthesis RightParenthesis
    {:
        output.add("CallExpr ::= NEW ID LPAREN RPAREN");
    :}
    | CallExpr Dot ID LeftParenthesis OptExprList RightParenthesis
    {:
        output.add("CallExpr ::= CallExpr DOT ID LPAREN OptExprList RPAREN");
    :}
    ;
